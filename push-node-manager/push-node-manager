#!/bin/bash
# Push Node Manager - Native Only Version
# Completely Docker-free Push Chain validator management

set -e

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"

# Load environment variables from .env if it exists
if [ -f "$SCRIPT_DIR/.env" ]; then
    export $(grep -v '^#' "$SCRIPT_DIR/.env" | xargs)
fi

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;94m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
NC='\033[0m'
BOLD='\033[1m'

# Print functions
print_status() {
    echo -e "${BLUE}$1${NC}"
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_error() {
    echo -e "${RED}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

# Native binary path
BUILD_DIR="$SCRIPT_DIR/build"
NATIVE_BINARY="$BUILD_DIR/pchaind"

# Check if binary exists and auto-setup if missing
if [ ! -f "$NATIVE_BINARY" ]; then
    print_warning "âŒ Native binary not found at: $NATIVE_BINARY"
    print_status "ğŸ”§ Running automatic dependency setup and build..."
    echo
    
    # Run setup script automatically
    if [ -f "$SCRIPT_DIR/setup-dependencies.sh" ]; then
        bash "$SCRIPT_DIR/setup-dependencies.sh"
        echo
        print_success "âœ… Auto-setup completed! Continuing with node start..."
        echo
    else
        print_error "âŒ Setup script not found: $SCRIPT_DIR/setup-dependencies.sh"
        exit 1
    fi
    
    # Verify binary was created
    if [ ! -f "$NATIVE_BINARY" ]; then
        print_error "âŒ Binary creation failed during auto-setup"
        exit 1
    fi
fi

# ASCII Art Banner
show_banner() {
    echo -e "${BOLD}${GREEN}"
    echo "    ____             __       ________          _      "
    echo "   / __ \\__  _______/ /_     / ____/ /_  ____ _(_)___  "
    echo "  / /_/ / / / / ___/ __ \\   / /   / __ \\/ __ \`/ / __ \\ "
    echo " / ____/ /_/ (__  ) / / /  / /___/ / / / /_/ / / / / / "
    echo "/_/    \\__,_/____/_/ /_/   \\____/_/ /_/\\__,_/_/_/ /_/  "
    echo -e "${NC}"
    echo -e "${BOLD}${YELLOW}            Push Node Manager${NC}"
    echo -e "${GREEN}        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo
}

# Chain configuration
CHAIN_ID="push_42101-1"
MONIKER="${MONIKER:-push-validator}"
DENOM="upc"
HOME_DIR="$HOME/.pchain"
GENESIS_DOMAIN="${GENESIS_DOMAIN:-rpc-testnet-donut-node1.push.org}"
GENESIS_RPC="https://$GENESIS_DOMAIN"

# Process management
PCHAIND_PID_FILE="$HOME_DIR/pchaind.pid"

# Check if node is running
is_node_running() {
    if [ -f "$PCHAIND_PID_FILE" ]; then
        PID=$(cat "$PCHAIND_PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then
            return 0
        else
            rm -f "$PCHAIND_PID_FILE"
            return 1
        fi
    fi
    return 1
}

# Start node in background
start_node() {
    print_status "ğŸš€ Starting Push Chain node..."
    
    # Comprehensive cleanup of port conflicts and stale processes
    print_status "ğŸ§¹ Cleaning up any port conflicts and stale processes..."
    
    # Kill processes using port 26657 (RPC)
    if lsof -ti:26657 >/dev/null 2>&1; then
        for pid in $(lsof -ti:26657 2>/dev/null); do
            kill -9 "$pid" 2>/dev/null || true
        done
    fi
    
    # Kill processes using port 26656 (P2P)
    if lsof -ti:26656 >/dev/null 2>&1; then
        for pid in $(lsof -ti:26656 2>/dev/null); do
            kill -9 "$pid" 2>/dev/null || true
        done
    fi
    
    # Kill any stale pchaind processes
    pkill -f pchaind 2>/dev/null || true
    
    # Remove stale PID file
    rm -f "$PCHAIND_PID_FILE" 2>/dev/null || true
    
    # Brief pause to ensure cleanup
    sleep 1
    
    # Clean setup like testnet script
    if [ ! -f "$HOME_DIR/config/config.toml" ]; then
        print_status "ğŸ§± Initializing chain: $MONIKER ($CHAIN_ID)"
        rm -rf "$HOME_DIR"
        
        # Initialize the chain (suppress verbose output)
        "$NATIVE_BINARY" init "$MONIKER" --chain-id "$CHAIN_ID" --default-denom "$DENOM" --home "$HOME_DIR" >/dev/null 2>&1
        
        print_status "ğŸŒ Fetching genesis.json from $GENESIS_RPC/genesis"
        curl -s "$GENESIS_RPC/genesis" | jq -r '.result.genesis' > "$HOME_DIR/config/genesis.json"
        
        print_status "ğŸ” Fetching validator node ID from /status"
        VALIDATOR_NODE_ID=$(curl -s "$GENESIS_RPC/status" | jq -r '.result.node_info.id')
        
        print_status "ğŸ” Resolving $GENESIS_DOMAIN to IP"
        VALIDATOR_IP=$(dig +short "$GENESIS_DOMAIN" | tail -n1)
        
        PERSISTENT_PEER="$VALIDATOR_NODE_ID@$VALIDATOR_IP:26656"
        print_status "ğŸ”— persistent_peers = $PERSISTENT_PEER"
        
        sed -i.bak \
            -e "s/^persistent_peers = .*/persistent_peers = \"$PERSISTENT_PEER\"/" \
            "$HOME_DIR/config/config.toml"
        
        print_success "âœ… Node configured for native execution"
    fi
    
    # Start in background
    mkdir -p "$HOME_DIR/logs"
    nohup "$NATIVE_BINARY" start --home "$HOME_DIR" > "$HOME_DIR/logs/pchaind.log" 2>&1 &
    echo $! > "$PCHAIND_PID_FILE"
    
    print_success "âœ… Node started in background (PID: $(cat "$PCHAIND_PID_FILE"))"
    print_status "ğŸ“œ Logs: tail -f $HOME_DIR/logs/pchaind.log"
}

# Stop node
stop_node() {
    print_status "ğŸ›‘ Stopping Push Chain node..."
    
    if is_node_running; then
        PID=$(cat "$PCHAIND_PID_FILE")
        kill "$PID"
        rm -f "$PCHAIND_PID_FILE"
        print_success "âœ… Node stopped (PID: $PID)"
    else
        print_warning "âš ï¸ Node is not running"
    fi
}

# Show node status
show_status() {
    print_status "ğŸ“Š Push Chain Node Status"
    echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    
    echo -e "${BOLD}${BLUE}Runtime Mode: ${GREEN}Native Execution${NC}"
    echo -e "  ${BOLD}Binary:${NC} $NATIVE_BINARY"
    # Get version safely with better error handling
    if [ -f "$NATIVE_BINARY" ]; then
        VERSION=$("$NATIVE_BINARY" version 2>/dev/null | head -n1 || echo "v1.0.1-native")
        # Fallback if version command doesn't work
        if [ -z "$VERSION" ] || [ "$VERSION" = "" ]; then
            VERSION="v1.0.1-native"
        fi
    else
        VERSION="Binary not found"
    fi
    echo -e "  ${BOLD}Version:${NC} $VERSION"
    echo
    
    if [ -f "$HOME_DIR/config/config.toml" ]; then
        print_success "âœ… Node initialized"
        
        if is_node_running; then
            print_success "âœ… Node is running (PID: $(cat "$PCHAIND_PID_FILE"))"
            
            # Get detailed status
            if command -v curl >/dev/null 2>&1 && command -v jq >/dev/null 2>&1; then
                NODE_STATUS=$(curl -s http://localhost:26657/status 2>/dev/null || echo "")
                
                if [ -n "$NODE_STATUS" ]; then
                    echo
                    echo -e "${BOLD}${BLUE}Node Information:${NC}"
                    echo -e "${GREEN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
                    
                    NODE_ID=$(echo "$NODE_STATUS" | jq -r '.result.node_info.id // "unknown"' 2>/dev/null)
                    NETWORK=$(echo "$NODE_STATUS" | jq -r '.result.node_info.network // "unknown"' 2>/dev/null)  
                    MONIKER=$(echo "$NODE_STATUS" | jq -r '.result.node_info.moniker // "unknown"' 2>/dev/null)
                    
                    echo -e "  ${BOLD}Node ID:${NC} ${YELLOW}$NODE_ID${NC}"
                    echo -e "  ${BOLD}Network:${NC} ${GREEN}$NETWORK${NC}"
                    echo -e "  ${BOLD}Moniker:${NC} ${BOLD}${WHITE}$MONIKER${NC}"
                    
                    echo
                    echo -e "${BOLD}${BLUE}Sync Status:${NC}"
                    echo -e "${GREEN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
                    
                    LOCAL_HEIGHT=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.latest_block_height // "0"' 2>/dev/null)
                    LATEST_TIME=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.latest_block_time // "unknown"' 2>/dev/null)
                    CATCHING_UP=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.catching_up // "true"' 2>/dev/null)
                    
                    echo -e "  ${BOLD}Block Height:${NC} ${GREEN}$LOCAL_HEIGHT${NC}"
                    echo -e "  ${BOLD}Block Time:${NC} $LATEST_TIME"
                    
                    if [ "$CATCHING_UP" = "false" ]; then
                        echo -e "  ${BOLD}Status:${NC} ${GREEN}âœ… Fully Synced${NC}"
                    else
                        echo -e "  ${BOLD}Status:${NC} ${YELLOW}â³ Syncing...${NC}"
                    fi
                else
                    print_warning "âš ï¸ Node is starting up..."
                fi
            else
                print_warning "âš ï¸ curl or jq not available - install for detailed status"
            fi
        else
            print_error "âŒ Node is not running"
            echo "Use: ./push-node-manager start"
        fi
    else
        print_error "âŒ Node not initialized"
        echo "Use: ./push-node-manager start"
    fi
}

# Show logs
show_logs() {
    print_status "ğŸ“œ Showing Push Chain logs..."
    
    if [ -f "$HOME_DIR/logs/pchaind.log" ]; then
        tail -f "$HOME_DIR/logs/pchaind.log"
    else
        print_warning "âš ï¸ No log file found"
        if is_node_running; then
            print_status "Node is running but logs not found at expected location"
        else
            print_status "Start the node first: ./push-node-manager start"
        fi
    fi
}

# Monitor sync progress
monitor_sync() {
    print_status "ğŸ“Š Real-time Sync Monitor"
    echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo "Press Ctrl+C to exit"
    echo
    
    if ! is_node_running; then
        print_error "âŒ Node is not running"
        echo "Start the node first: ./push-node-manager start"
        exit 1
    fi
    
    # Check if curl and jq are available
    if ! command -v curl >/dev/null 2>&1 || ! command -v jq >/dev/null 2>&1; then
        print_error "âŒ curl or jq not available"
        print_status "Install with: sudo apt-get install curl jq (Linux) or brew install curl jq (macOS)"
        exit 1
    fi
    
    local previous_height=0
    local start_time=$(date +%s)
    
    while true; do
        # Get node status
        NODE_STATUS=$(curl -s http://localhost:26657/status 2>/dev/null || echo "")
        
        if [ -n "$NODE_STATUS" ]; then
            # Extract sync information
            LOCAL_HEIGHT=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.latest_block_height // "0"' 2>/dev/null || echo "0")
            CATCHING_UP=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.catching_up // "true"' 2>/dev/null || echo "true")
            LATEST_TIME=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.latest_block_time // "unknown"' 2>/dev/null || echo "unknown")
            
            # Fetch remote (network) latest height to compute progress
            REMOTE_STATUS=$(curl -s "$GENESIS_RPC/status" 2>/dev/null || echo "")
            REMOTE_HEIGHT=$(echo "$REMOTE_STATUS" | jq -r '.result.sync_info.latest_block_height // "0"' 2>/dev/null || echo "0")
            # Normalize to integers if possible
            [[ "$REMOTE_HEIGHT" =~ ^[0-9]+$ ]] || REMOTE_HEIGHT=0

            # Get network information
            MONIKER=$(echo "$NODE_STATUS" | jq -r '.result.node_info.moniker // "unknown"' 2>/dev/null || echo "unknown")
            NETWORK=$(echo "$NODE_STATUS" | jq -r '.result.node_info.network // "unknown"' 2>/dev/null || echo "unknown")
            
            # Calculate sync rate
            local current_time=$(date +%s)
            local elapsed=$((current_time - start_time))
            local height_diff=$((LOCAL_HEIGHT - previous_height))
            local blocks_per_sec=0
            
            if [ $elapsed -gt 0 ] && [ $height_diff -gt 0 ]; then
                blocks_per_sec=$(echo "scale=2; $height_diff / $elapsed" | bc 2>/dev/null || echo "0")
            fi
            
            # Compute progress percentage and render a progress bar
            PROGRESS_PERCENT="0.00"
            if [ "$REMOTE_HEIGHT" -gt 0 ]; then
                if [ "$LOCAL_HEIGHT" -ge "$REMOTE_HEIGHT" ]; then
                    PROGRESS_PERCENT="100.00"
                else
                    PROGRESS_PERCENT=$(echo "scale=2; 100 * $LOCAL_HEIGHT / $REMOTE_HEIGHT" | bc 2>/dev/null || echo "0.00")
                fi
            fi
            BAR_WIDTH=30
            FILLED=$(echo "$PROGRESS_PERCENT * $BAR_WIDTH / 100" | bc 2>/dev/null | cut -d'.' -f1)
            [ -z "$FILLED" ] && FILLED=0
            EMPTY=$((BAR_WIDTH - FILLED))
            BAR_FILLED=$(printf "%0.sâ–ˆ" $(seq 1 ${FILLED}))
            BAR_EMPTY=$(printf "%0.sâ–‘" $(seq 1 ${EMPTY}))
            PROGRESS_BAR="${BAR_FILLED}${BAR_EMPTY}"
            
            # Clear screen and show status
            clear
            echo -e "${BOLD}${GREEN}Push Chain Sync Monitor${NC}"
            echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo
            echo -e "${BOLD}${BLUE}Node Information:${NC}"
            echo -e "  ${BOLD}Moniker:${NC} ${WHITE}$MONIKER${NC}"
            echo -e "  ${BOLD}Network:${NC} ${GREEN}$NETWORK${NC}"
            echo
            
            echo -e "${BOLD}${BLUE}Sync Status:${NC}"
            echo -e "  ${BOLD}Block Height:${NC} ${GREEN}$LOCAL_HEIGHT${NC}"
            echo -e "  ${BOLD}Last Block:${NC} $LATEST_TIME"
            
            if [ "$CATCHING_UP" = "false" ]; then
                echo -e "  ${BOLD}Status:${NC} ${GREEN}âœ… FULLY SYNCED${NC}"
                echo -e "  ${BOLD}Sync Rate:${NC} ${GREEN}Maintaining sync${NC}"
            else
                echo -e "  ${BOLD}Status:${NC} ${YELLOW}â³ SYNCING...${NC}"
                if [ "$blocks_per_sec" != "0" ]; then
                    echo -e "  ${BOLD}Sync Rate:${NC} ${CYAN}${blocks_per_sec} blocks/sec${NC}"
                    # Estimate ETA based on remaining blocks and current rate
                    if [ "$REMOTE_HEIGHT" -gt "$LOCAL_HEIGHT" ]; then
                        REMAINING_BLOCKS=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
                        # Ensure blocks_per_sec > 0 using bc for float compare
                        RATE_POS=$(echo "$blocks_per_sec > 0" | bc 2>/dev/null || echo 0)
                        if [ "$RATE_POS" -eq 1 ]; then
                            ETA_SECONDS=$(echo "$REMAINING_BLOCKS / $blocks_per_sec" | bc 2>/dev/null || echo 0)
                            if [ "$ETA_SECONDS" -gt 0 ] 2>/dev/null; then
                                ETA_H=$((ETA_SECONDS / 3600))
                                ETA_M=$(((ETA_SECONDS % 3600) / 60))
                                ETA_S=$((ETA_SECONDS % 60))
                                if [ "$ETA_H" -gt 0 ]; then
                                    echo -e "  ${BOLD}ETA:${NC} ~${GREEN}${ETA_H}h ${ETA_M}m${NC}"
                                elif [ "$ETA_M" -gt 0 ]; then
                                    echo -e "  ${BOLD}ETA:${NC} ~${GREEN}${ETA_M}m ${ETA_S}s${NC}"
                                else
                                    echo -e "  ${BOLD}ETA:${NC} ~${GREEN}${ETA_S}s${NC}"
                                fi
                            fi
                        fi
                    fi
                fi
            fi
            
            echo
            echo -e "${BOLD}${BLUE}Runtime Stats:${NC}"
            echo -e "  ${BOLD}Monitoring Time:${NC} ${elapsed}s"
            if [ "$REMOTE_HEIGHT" -gt 0 ]; then
                echo -e "  ${BOLD}Progress:${NC} [${PROGRESS_BAR}] ${GREEN}${PROGRESS_PERCENT}%${NC} (${LOCAL_HEIGHT}/${REMOTE_HEIGHT})"
            else
                echo -e "  ${BOLD}Progress:${NC} [${PROGRESS_BAR}] ${YELLOW}unknown target height${NC} (${LOCAL_HEIGHT}/?)"
            fi
            
            if [ "$CATCHING_UP" = "false" ]; then
                echo
                echo -e "${BOLD}${GREEN}ğŸ‰ Node is fully synced and ready!${NC}"
                echo -e "You can now register as validator: ${BOLD}./push-node-manager register-validator${NC}"
            fi
            
            previous_height=$LOCAL_HEIGHT
            
        else
            clear
            echo -e "${BOLD}${YELLOW}âš ï¸ Waiting for node to respond...${NC}"
            echo "Make sure the node is running: ./push-node-manager status"
        fi
        
        echo
        echo -e "${BLUE}Press Ctrl+C to exit monitor${NC}"
        sleep 3
    done
}

# Register validator
register_validator() {
    print_status "ğŸš€ Starting validator registration..."
    echo
    echo -e "${BOLD}This simplified wizard will:${NC}"
    echo -e "  ${GREEN}âœ“${NC} Create a validator key"
    echo -e "  ${GREEN}âœ“${NC} Help you fund the account"  
    echo -e "  ${GREEN}âœ“${NC} Register your node as a validator"
    echo
    
    if [ -f "$SCRIPT_DIR/scripts/register-validator.sh" ]; then
        bash "$SCRIPT_DIR/scripts/register-validator.sh"
    else
        print_error "âŒ Validator registration script not found!"
        exit 1
    fi
}

# Configure genesis RPC endpoint
configure_genesis() {
    if [ -n "$2" ]; then
        NEW_GENESIS_DOMAIN="$2"
        print_status "ğŸ”§ Setting genesis RPC domain to: $NEW_GENESIS_DOMAIN"
        
        # Create/update .env file for persistence
        ENV_FILE="$SCRIPT_DIR/.env"
        if [ -f "$ENV_FILE" ]; then
            # Remove existing GENESIS_DOMAIN line
            grep -v "^GENESIS_DOMAIN=" "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE" || touch "$ENV_FILE"
        fi
        echo "GENESIS_DOMAIN=$NEW_GENESIS_DOMAIN" >> "$ENV_FILE"
        
        print_success "âœ… Genesis RPC configured: https://$NEW_GENESIS_DOMAIN"
        print_status "ğŸ’¡ This setting will persist across restarts"
        print_status "ğŸ”„ Restart the node to use the new endpoint: ./push-node-manager restart"
    else
        print_status "ğŸ“¡ Current Genesis RPC Configuration"
        echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo -e "  ${BOLD}Domain:${NC} ${GREEN}$GENESIS_DOMAIN${NC}"
        echo -e "  ${BOLD}Full URL:${NC} ${CYAN}$GENESIS_RPC${NC}"
        echo
        print_status "ğŸ’¡ To change: ./push-node-manager set-genesis <domain>"
        print_status "   Example: ./push-node-manager set-genesis rpc.custom-node.org"
        echo
        print_status "ğŸ”§ Default: rpc-testnet-donut-node1.push.org"
    fi
}

# Check wallet balance
check_balance() {
    WALLET_NAME="${2:-validator-key}"
    print_status "ğŸ’° Checking wallet balance..."
    
    # Check if wallet exists
    if ! "$NATIVE_BINARY" keys show "$WALLET_NAME" --keyring-backend test --home "$HOME_DIR" >/dev/null 2>&1; then
        print_error "âŒ Wallet '$WALLET_NAME' not found!"
        echo "Create a wallet first using: ./push-node-manager register-validator"
        exit 1
    fi
    
    # Get address
    ADDRESS=$("$NATIVE_BINARY" keys show "$WALLET_NAME" -a --keyring-backend test --home "$HOME_DIR" 2>/dev/null)
    
    echo "Wallet: $WALLET_NAME"
    echo "Address: $ADDRESS"
    
    # Get balance from RPC
    BALANCE=$("$NATIVE_BINARY" query bank balances "$ADDRESS" --node tcp://localhost:26657 -o json 2>/dev/null | \
        jq -r '.balances[] | select(.denom=="upc") | .amount // "0"' || echo "0")
    
    if [ "$BALANCE" != "0" ] && [ -n "$BALANCE" ]; then
        # Convert to PUSH (divide by 10^18) using awk
        PUSH_AMOUNT=$(awk -v bal="$BALANCE" 'BEGIN {printf "%.6f", bal/1000000000000000000}')
        print_success "Balance: $PUSH_AMOUNT PUSH"
    else
        print_warning "Balance: 0 PUSH"
        
        # Convert to EVM address for faucet
        EVM_ADDRESS=$("$NATIVE_BINARY" debug addr "$ADDRESS" --home "$HOME_DIR" 2>/dev/null | grep "hex" | awk '{print "0x"$3}')
        
        if [ -n "$EVM_ADDRESS" ]; then
            echo
            echo "To get test tokens:"
            echo -e "${GREEN}1. Visit: https://faucet.push.org${NC}"
            echo -e "${GREEN}2. Use this address: ${BOLD}$EVM_ADDRESS${NC}"
        else
            echo "Get test tokens at: https://faucet.push.org"
        fi
    fi
}

# List validators
list_validators() {
    print_status "ğŸ‘¥ Active Push Chain Validators"
    echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    
    if is_node_running; then
        # Check if local node is synced
        SYNC_STATUS=$("$NATIVE_BINARY" status --node tcp://localhost:26657 2>/dev/null | jq -r '.sync_info.catching_up // "true"' 2>/dev/null || echo "true")
        
        if [ "$SYNC_STATUS" = "true" ]; then
            print_status "âš ï¸  Local node syncing - using remote RPC for accurate validator list"
            NODE_ENDPOINT="$GENESIS_RPC:443"
        else
            NODE_ENDPOINT="tcp://localhost:26657"
        fi
        
        VALIDATORS=$("$NATIVE_BINARY" query staking validators --output json --node "$NODE_ENDPOINT" 2>/dev/null | jq -r '.validators[]' 2>/dev/null || echo "")
        
        if [ -n "$VALIDATORS" ]; then
            echo
            echo -e "${BOLD}${YELLOW}VALIDATOR                 STATUS          STAKE (PC)   COMMISSION${NC}"
            echo -e "${BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
            
            echo "$VALIDATORS" | jq -r '
                (.description.moniker // "unknown") + "|" + 
                (if .status == "BOND_STATUS_BONDED" then "BONDED" 
                 elif .status == "BOND_STATUS_UNBONDING" then "UNBONDING"
                 elif .status == "BOND_STATUS_UNBONDED" then "UNBONDED"
                 else .status end) + "|" +
                ((.tokens | tonumber / 1000000000000000000) | tostring | split(".")[0]) + "|" +
                ((.commission.commission_rates.rate | tonumber * 100) | tostring | split(".")[0]) + "%"
            ' 2>/dev/null | while IFS='|' read -r moniker status tokens commission; do
                # Color code status using printf with -e flag
                case "$status" in
                    "BONDED")     status_colored="$(printf "\e[0;32mâœ… %s\e[0m" "$status")" ;;
                    "UNBONDING")  status_colored="$(printf "\e[0;33mâ³ %s\e[0m" "$status")" ;;
                    "UNBONDED")   status_colored="$(printf "\e[0;31mâŒ %s\e[0m" "$status")" ;;
                    *)            status_colored="$(printf "\e[0;34m%s\e[0m" "$status")" ;;
                esac
                
                # Format the output line with proper spacing using printf
                printf "\e[1m%-25s\e[0m %s \e[0;36m%12s\e[0m \e[0;35m%15s\e[0m\n" "$moniker" "$status_colored" "$tokens" "$commission"
            done
            
            echo
            echo -e "${BLUE}Total Validators: $(echo "$VALIDATORS" | jq -s length)${NC}"
        else
            print_warning "No validators found or node not synced"
        fi
    else
        print_error "âŒ Node must be running to query validators"
        echo "Start the node first: ./push-node-manager start"
    fi
}

# Show help
show_help() {
    printf "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    printf "${BOLD}${YELLOW}ğŸš€ Push Node Manager${NC}\n"
    printf "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    printf "\n"
    printf "Usage: ./push-node-manager [command] [options]\n"
    printf "\n"
    printf "${BOLD}${CYAN}âš¡ Commands:${NC}\n"
    printf "${BOLD}${CYAN}ğŸ”§ Node Management:${NC}\n"
    printf "  ${YELLOW}start${NC}              ğŸš€ Start the Push node\n"
    printf "  ${YELLOW}stop${NC}               ğŸ›‘ Stop the Push node\n"
    printf "  ${YELLOW}restart${NC}            ğŸ”„ Restart the Push node\n"
    printf "  ${YELLOW}status${NC}             ğŸ“Š Show node sync status and validator info\n"
    printf "  ${YELLOW}sync${NC}               ğŸ“ˆ Real-time sync monitoring dashboard\n"
    printf "  ${YELLOW}logs${NC}               ğŸ“œ Show node logs (live tail)\n"
    printf "  ${YELLOW}setup-deps${NC}         ğŸ“¦ Install dependencies and build binary\n"
    printf "  ${YELLOW}reset${NC}              ğŸ”„ Reset blockchain data (keeps wallets)\n"
    printf "  ${YELLOW}help${NC}               â“ Show this help message\n"
    printf "\n"
    printf "${BOLD}${CYAN}ğŸ¯ Validator Operations:${NC}\n"
    printf "  ${YELLOW}register-validator${NC} ğŸ” Validator registration\n"
    printf "  ${YELLOW}validators${NC}         ğŸ‘¥ List all active validators on the network\n"
    printf "  ${YELLOW}balance${NC} [wallet]   ğŸ’° Check wallet balance (default: validator-key)\n"
    printf "\n"
    printf "${BOLD}${CYAN}ğŸŒ Network Configuration:${NC}\n"
    printf "  ${YELLOW}genesis${NC}            ğŸ“¡ Show current genesis RPC endpoint\n"
    printf "  ${YELLOW}set-genesis${NC} <url>  ğŸ”§ Set custom genesis RPC endpoint\n"
    printf "\n"
    printf "${BOLD}${MAGENTA}ğŸ’¡ Quick Start Guide:${NC}\n"
    printf "  ${CYAN}1.${NC} ${BOLD}./push-node-manager start${NC}\n"
    printf "  ${CYAN}2.${NC} ${BOLD}./push-node-manager status${NC}\n"
    printf "  ${CYAN}3.${NC} ${BOLD}./push-node-manager register-validator${NC}\n"
    printf "  ${CYAN}4.${NC} ${BOLD}./push-node-manager sync${NC}\n"
    printf "\n"
    printf "${BOLD}${CYAN}ğŸŒ Network Info:${NC}\n"
    printf "  ${GREEN}ğŸ†” Chain ID:${NC}     ${YELLOW}push_42101-1${NC}\n"
    printf "  ${GREEN}ğŸ§ª Network:${NC}      ${YELLOW}Testnet${NC}\n"
    printf "  ${GREEN}ğŸ”— RPC:${NC}          ${YELLOW}http://localhost:26657${NC}\n"
    printf "  ${GREEN}ğŸš° Faucet:${NC}       ${YELLOW}https://faucet.push.org${NC}\n"
    printf "  ${GREEN}ğŸ’ Min Stake:${NC}    ${YELLOW}2 PC${NC}\n"
    printf "\n"
    printf "${BOLD}${CYAN}ğŸ“ Notes:${NC}\n"
    printf "  ${BLUE}â€¢${NC} Node runs as background daemon\n"
    printf "  ${BLUE}â€¢${NC} Logs: ${YELLOW}~/.pchain/logs/pchaind.log${NC}\n"
    printf "  ${BLUE}â€¢${NC} Keys: ${YELLOW}~/.pchain directory${NC}\n"
    printf "\n"
}

# Command handling
case "${1:-help}" in
    start|run)
        show_banner
        start_node
        ;;
        
    stop)
        stop_node
        ;;
        
    restart)
        stop_node
        sleep 2
        start_node
        ;;
        
    status)
        show_status
        ;;
        
    sync)
        monitor_sync
        ;;
        
    logs)
        show_logs
        ;;
        
    register-validator|setup)
        show_banner
        register_validator
        ;;
        
    balance|wallet)
        check_balance "$@"
        ;;
        
    validators)
        list_validators
        ;;
        
    set-genesis)
        configure_genesis "$@"
        ;;
        
    genesis)
        configure_genesis "$@"
        ;;
        
    setup-deps)
        print_status "ğŸ”§ Running dependency setup..."
        bash "$SCRIPT_DIR/setup-dependencies.sh"
        ;;
        
    reset)
        print_warning "âš ï¸ This will reset all blockchain data (wallets will be preserved)"
        read -p "Continue? (yes/no): " confirm
        if [[ "$confirm" =~ ^[Yy][Ee][Ss]$ ]]; then
            stop_node
            print_status "ğŸ§¹ Removing blockchain data..."
            rm -rf "$HOME_DIR/data"
            rm -f "$HOME_DIR/config/genesis.json"
            rm -f "$HOME_DIR/config/addrbook.json"
            rm -f "$HOME_DIR/config/config.toml.bak"
            
            # Additional thorough cleanup for AppHash errors
            print_status "ğŸ”§ Performing thorough cleanup..."
            rm -rf "$HOME_DIR/data" 2>/dev/null || true
            rm -rf "$HOME_DIR/wasm" 2>/dev/null || true
            rm -f "$HOME_DIR/config/config.toml" 2>/dev/null || true
            rm -rf "$HOME_DIR/logs" 2>/dev/null || true
            
            print_success "âœ… Blockchain data reset completely"
            print_status "Node will be completely re-initialized on next start"
            print_status "Start the node to re-sync: ./push-node-manager start"
        fi
        ;;
        
    help|--help|-h|"")
        show_help
        ;;
        
    *)
        print_error "âŒ Unknown command: $1"
        echo "Use './push-node-manager help' for usage information"
        exit 1
        ;;
esac