#!/usr/bin/env bash
# Push Validator Manager - Native Only Version
# Completely Docker-free Push Chain validator management

set -euo pipefail
IFS=$'\n\t'

# Resolve script directory robustly, following symlinks
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SCRIPT_SOURCE" ]; do
  BASE_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
  SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
  [[ "$SCRIPT_SOURCE" != /* ]] && SCRIPT_SOURCE="$BASE_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
cd "$SCRIPT_DIR"

# Load environment variables from .env if it exists (robust, supports spaces)
if [ -f "$SCRIPT_DIR/.env" ]; then
    set -a
    . "$SCRIPT_DIR/.env"
    set +a
fi

# Colors for output - Standardized palette
GREEN='\033[0;32m'      # Success messages
RED='\033[0;31m'        # Error messages  
YELLOW='\033[0;33m'     # Warning messages
CYAN='\033[0;36m'       # Status/info messages
BLUE='\033[1;94m'       # Headers/titles (bright blue)
MAGENTA='\033[0;35m'    # Accent/highlight data
WHITE='\033[1;37m'      # Important values (bold white)
NC='\033[0m'            # No color/reset
BOLD='\033[1m'          # Emphasis
DIM='\033[90m'          # Dim gray (for empty bar)

# Print functions - Unified across all scripts
print_status() {
    echo -e "${CYAN}$1${NC}"
}

print_header() {
    echo -e "${BLUE}$1${NC}"
}

print_value() {
    echo -e "${MAGENTA}$1${NC}"
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_error() {
    echo -e "${RED}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

# Compute a reasonable progress bar width based on terminal size
# Override with PROGRESS_BAR_WIDTH env var (10..100)
compute_bar_width() {
    local override="${PROGRESS_BAR_WIDTH:-}"
    if [[ "$override" =~ ^[0-9]+$ ]] && [ "$override" -ge 10 ] && [ "$override" -le 100 ]; then
        echo "$override"
        return 0
    fi
    local cols=80
    if [ -t 1 ]; then
        cols=$(tput cols 2>/dev/null || echo 80)
        [[ "$cols" =~ ^[0-9]+$ ]] || cols=80
    fi
    if [ "$cols" -ge 140 ]; then
        echo 50
    elif [ "$cols" -ge 100 ]; then
        echo 40
    else
        echo 30
    fi
}

# Dependency helpers
require_cmd() {
    if ! command -v "$1" >/dev/null 2>&1; then
        echo "Missing dependency: $1" >&2
        exit 1
    fi
}

require_one_of() {
    for cmd in "$@"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            return 0
        fi
    done
    echo "Missing dependency: one of [$*] is required" >&2
    exit 1
}

# Resolve hostname to single IPv4 address using dig/nslookup/host
resolve_host_ip() {
    local host="$1"
    local ip=""
    if command -v dig >/dev/null 2>&1; then
        ip=$(dig +short "$host" A | tail -n1)
    elif command -v nslookup >/dev/null 2>&1; then
        ip=$(nslookup "$host" 2>/dev/null | awk '/^Address: /{print $2; found=1} END{if(!found) exit 1}') || true
    elif command -v host >/dev/null 2>&1; then
        ip=$(host "$host" 2>/dev/null | awk '/ has address /{print $4; exit}') || true
    fi
    echo "$ip"
}

# Kill process listening on port if it is pchaind; try TERM then KILL
kill_pchaind_on_port() {
    local port="$1"
    local pids="$(lsof -tiTCP:"$port" -sTCP:LISTEN 2>/dev/null || true)"
    for pid in $pids; do
        if ps -o comm= -p "$pid" | grep -q "pchaind"; then
            kill "$pid" 2>/dev/null || true
            sleep 1
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
            fi
        fi
    done
}

# Native binary path (prefer build/, fallback to scripts/build/)
BUILD_DIR="$SCRIPT_DIR/build"
SCRIPTS_BUILD_DIR="$SCRIPT_DIR/scripts/build"
NATIVE_BINARY="$BUILD_DIR/pchaind"

resolve_binary_path() {
    if [ -f "$BUILD_DIR/pchaind" ]; then
        NATIVE_BINARY="$BUILD_DIR/pchaind"
    elif [ -f "$SCRIPTS_BUILD_DIR/pchaind" ]; then
        NATIVE_BINARY="$SCRIPTS_BUILD_DIR/pchaind"
    else
        NATIVE_BINARY="$BUILD_DIR/pchaind" # default
    fi
}

resolve_binary_path

# Check if binary exists and auto-setup if missing
if [ ! -f "$NATIVE_BINARY" ]; then
    print_warning "‚ùå Native binary not found at: $NATIVE_BINARY"
    print_status "üîß Running automatic dependency setup and build..."
    echo
    
    # Run setup script automatically
    if [ -f "$SCRIPT_DIR/scripts/setup-dependencies.sh" ]; then
        bash "$SCRIPT_DIR/scripts/setup-dependencies.sh"
        echo
        print_success "‚úÖ Auto-setup completed! Continuing with node start..."
        echo
        # Ensure convenience symlink exists
        mkdir -p "$BUILD_DIR" 2>/dev/null || true
        if [ -f "$SCRIPTS_BUILD_DIR/pchaind" ] && [ ! -f "$BUILD_DIR/pchaind" ]; then
            ln -sf "../scripts/build/pchaind" "$BUILD_DIR/pchaind" 2>/dev/null || true
        fi
        # Re-resolve binary path after setup
        resolve_binary_path
    else
        print_error "‚ùå Setup script not found: $SCRIPT_DIR/scripts/setup-dependencies.sh"
        exit 1
    fi
    
    # Verify binary was created
    if [ ! -f "$NATIVE_BINARY" ]; then
        print_error "‚ùå Binary creation failed during auto-setup"
        exit 1
    fi
fi

# Verify critical dependencies up front
require_cmd curl
require_cmd jq
require_cmd awk
require_cmd sed
require_cmd bc
require_cmd lsof
require_cmd nohup
require_one_of dig nslookup host

# Fast, resilient HTTP getter with short timeouts
http_get_quick() {
    # Usage: http_get_quick <url> [max_time_seconds]
    local url="$1"
    local max_time="${2:-3}"
    curl -fsS --connect-timeout 1 --max-time "$max_time" "$url" 2>/dev/null || echo ""
}

# ASCII Art Banner
show_banner() {
    echo -e "${BOLD}${GREEN}"
    echo "    ____             __       ________          _      "
    echo "   / __ \\__  _______/ /_     / ____/ /_  ____ _(_)___  "
    echo "  / /_/ / / / / ___/ __ \\   / /   / __ \\/ __ \`/ / __ \\ "
    echo " / ____/ /_/ (__  ) / / /  / /___/ / / / /_/ / / / / / "
    echo "/_/    \\__,_/____/_/ /_/   \\____/_/ /_/\\__,_/_/_/ /_/  "
    echo -e "${NC}"
    echo -e "${BOLD}${YELLOW}            Push Validator Manager${NC}"
    echo -e "${GREEN}        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo
}

# Chain configuration
CHAIN_ID="push_42101-1"
MONIKER="${MONIKER:-push-validator}"
DENOM="upc"
HOME_DIR="$HOME/.pchain"
GENESIS_DOMAIN="${GENESIS_DOMAIN:-rpc-testnet-donut-node1.push.org}"
GENESIS_RPC="https://$GENESIS_DOMAIN"
KEYRING_BACKEND="${KEYRING_BACKEND:-test}"

# Process management
PCHAIND_PID_FILE="$HOME_DIR/pchaind.pid"

# Check if node is running
is_node_running() {
    # Check PID file
    if [ -f "$PCHAIND_PID_FILE" ]; then
        PID=$(cat "$PCHAIND_PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then
            # Verify it's actually pchaind process
            if ps -p "$PID" -o comm= | grep -q "pchaind"; then
                return 0
            fi
        fi
        # PID file exists but process not found or wrong process - clean up
        rm -f "$PCHAIND_PID_FILE" 2>/dev/null || true
    fi
    
    # Fallback: check if pchaind is running and listening on expected port
    if pgrep -f "pchaind.*start.*--home.*$HOME_DIR" > /dev/null 2>&1; then
        # Found process, update PID file
        local FOUND_PID=$(pgrep -f "pchaind.*start.*--home.*$HOME_DIR" | head -1)
        echo "$FOUND_PID" > "$PCHAIND_PID_FILE"
        return 0
    fi
    
    return 1
}

# Start node in background
start_node() {
    echo  # Add blank line for spacing
    print_status "üöÄ Starting Push Chain node..."
    
    # If already running, do not disturb the running process
    if is_node_running; then
        print_success "‚úÖ Node already running (PID: $(cat \"$PCHAIND_PID_FILE\"))"
        print_status "Use: ${BOLD}push-validator-manager sync${NC} to monitor or ${BOLD}push-validator-manager status${NC}"
        return 0
    fi
    
    # Comprehensive cleanup of port conflicts and stale processes (silent)
    
    # Kill only pchaind processes bound to the known ports
    kill_pchaind_on_port 26657
    kill_pchaind_on_port 26656
    
    # Remove stale PID file
    rm -f "$PCHAIND_PID_FILE" 2>/dev/null || true
    
    # Brief pause to ensure cleanup
    sleep 1
    
    # Initialize if needed
    if [ ! -f "$HOME_DIR/config/config.toml" ]; then
        print_status "üß± Initializing chain: $MONIKER ($CHAIN_ID)"
        mkdir -p "$HOME_DIR/config" "$HOME_DIR/logs"
        
        # Initialize the chain (suppress verbose output)
        "$NATIVE_BINARY" init "$MONIKER" --chain-id "$CHAIN_ID" --default-denom "$DENOM" --home "$HOME_DIR" >/dev/null 2>&1
        
        print_status "üåç Fetching genesis.json from $GENESIS_RPC/genesis"
        if ! http_get_quick "$GENESIS_RPC/genesis" 5 | jq -r '.result.genesis' > "$HOME_DIR/config/genesis.json"; then
            print_error "‚ùå Failed to fetch genesis from $GENESIS_RPC"
            exit 1
        fi
        
        print_status "üîç Fetching available peers from network"
        # Try to get multiple peers from the network
        PEERS_JSON=$(http_get_quick "$GENESIS_RPC/net_info" 3)
        [ -n "$PEERS_JSON" ] || PEERS_JSON='{}'
        PERSISTENT_PEERS=""
        
        # Extract peers from net_info if available
        if [ -n "$PEERS_JSON" ] && [ "$PEERS_JSON" != '{}' ]; then
            PEER_LIST=$(echo "$PEERS_JSON" | jq -r '.result.peers[]? | "\(.node_info.id)@\(.remote_ip):26656"' 2>/dev/null | head -3 || true)
            if [ -n "$PEER_LIST" ]; then
                PERSISTENT_PEERS=$(echo "$PEER_LIST" | tr '\n' ',' | sed 's/,$//')
                print_status "üîó Found multiple peers from network"
            fi
        fi
        
        # Fallback to single peer from status endpoint
        if [ -z "$PERSISTENT_PEERS" ]; then
            print_status "üîç Fetching validator node ID from /status"
            VALIDATOR_NODE_ID=$(http_get_quick "$GENESIS_RPC/status" 3 | jq -r '.result.node_info.id // empty')
            if [ -z "${VALIDATOR_NODE_ID}" ]; then
                print_error "‚ùå Failed to query validator node ID from $GENESIS_RPC/status"
                exit 1
            fi
            
            print_status "üîç Resolving $GENESIS_DOMAIN to IP"
            VALIDATOR_IP=$(resolve_host_ip "$GENESIS_DOMAIN")
            if [ -z "${VALIDATOR_IP}" ]; then
                print_error "‚ùå Failed to resolve IP for $GENESIS_DOMAIN"
                exit 1
            fi
            
            PERSISTENT_PEERS="$VALIDATOR_NODE_ID@$VALIDATOR_IP:26656"
        fi
        
        print_status "üîó persistent_peers = $PERSISTENT_PEERS"
        
        sed -i.bak \
            -e "s/^persistent_peers = .*/persistent_peers = \"$PERSISTENT_PEERS\"/" \
            -e "s/^addr_book_strict = .*/addr_book_strict = false/" \
            "$HOME_DIR/config/config.toml"
        
        print_success "‚úÖ Node configured for native execution"
    fi

    # Ensure genesis.json exists even if config was present
    if [ ! -f "$HOME_DIR/config/genesis.json" ]; then
        if ! http_get_quick "$GENESIS_RPC/genesis" 5 | jq -r '.result.genesis' > "$HOME_DIR/config/genesis.json"; then
            print_error "‚ùå Failed to fetch genesis from $GENESIS_RPC"
            exit 1
        fi

        # Also refresh persistent_peers to be safe (silent)
        
        # Try to get multiple peers from the network
        PEERS_JSON=$(http_get_quick "$GENESIS_RPC/net_info" 3)
        [ -n "$PEERS_JSON" ] || PEERS_JSON='{}'
        PERSISTENT_PEERS=""
        
        # Extract peers from net_info if available
        if [ -n "$PEERS_JSON" ] && [ "$PEERS_JSON" != '{}' ]; then
            PEER_LIST=$(echo "$PEERS_JSON" | jq -r '.result.peers[]? | "\(.node_info.id)@\(.remote_ip):26656"' 2>/dev/null | head -3 || true)
            if [ -n "$PEER_LIST" ]; then
                PERSISTENT_PEERS=$(echo "$PEER_LIST" | tr '\n' ',' | sed 's/,$//')
            fi
        fi
        
        # Fallback to single peer
        if [ -z "$PERSISTENT_PEERS" ]; then
            VALIDATOR_NODE_ID=$(http_get_quick "$GENESIS_RPC/status" 3 | jq -r '.result.node_info.id // empty')
            VALIDATOR_IP=$(resolve_host_ip "$GENESIS_DOMAIN")
            if [ -n "$VALIDATOR_NODE_ID" ] && [ -n "$VALIDATOR_IP" ]; then
                PERSISTENT_PEERS="$VALIDATOR_NODE_ID@$VALIDATOR_IP:26656"
            fi
        fi
        
        if [ -n "$PERSISTENT_PEERS" ]; then
            sed -i.bak -e "s/^persistent_peers = .*/persistent_peers = \"$PERSISTENT_PEERS\"/" -e "s/^addr_book_strict = .*/addr_book_strict = false/" "$HOME_DIR/config/config.toml"
        fi
    fi

    # Ensure priv_validator_state.json exists to avoid CometBFT panic when data was wiped
    if [ ! -f "$HOME_DIR/data/priv_validator_state.json" ]; then
        mkdir -p "$HOME_DIR/data"
        cat > "$HOME_DIR/data/priv_validator_state.json" <<'STATEEOF'
{
  "height": "0",
  "round": 0,
  "step": 0
}
STATEEOF
    fi
    
    # Start in background
    mkdir -p "$HOME_DIR/logs"
    nohup "$NATIVE_BINARY" start --home "$HOME_DIR" > "$HOME_DIR/logs/pchaind.log" 2>&1 &
    PID=$!
    echo $PID > "$PCHAIND_PID_FILE"
    
    # Wait a moment and verify the process actually started
    sleep 1
    if ! kill -0 "$PID" 2>/dev/null; then
        print_error "‚ùå Node failed to start - process exited immediately"
        if [ -f "$HOME_DIR/logs/pchaind.log" ]; then
            print_warning "Last log entries:"
            tail -20 "$HOME_DIR/logs/pchaind.log"
        fi
        rm -f "$PCHAIND_PID_FILE"
        return 1
    fi
    
    print_success "‚úÖ Node started successfully"
    
    # Show sync status (safe - won't kill node on Ctrl+C)
    show_sync_after_start
}

# Safe sync monitoring that doesn't kill the node on Ctrl+C
show_sync_after_start() {
    # Run monitor in a subshell; monitor handles Ctrl+C and exits cleanly.
    (
        # Give node a moment to initialize
        sleep 3
        # Start monitoring (prefer WebSocket, fallback to polling)
        monitor_sync_auto --compact
    )
    # Return 0 so the parent script continues normally
    return 0
}

# Stop node
stop_node() {
    echo  # Add blank line for spacing
    print_status "üõë Stopping Push Chain node..."
    
    if is_node_running; then
        PID=$(cat "$PCHAIND_PID_FILE")
        kill "$PID" 2>/dev/null || true
        # wait up to 5s
        for i in {1..5}; do
            if ! kill -0 "$PID" 2>/dev/null; then
                break
            fi
            sleep 1
        done
        if kill -0 "$PID" 2>/dev/null; then
            kill -9 "$PID" 2>/dev/null || true
        fi
        rm -f "$PCHAIND_PID_FILE" 2>/dev/null || true
        print_success "‚úÖ Node stop signal sent (PID: $PID)"
        # Extra safety: ensure no stray pchaind still listens on known ports
        kill_pchaind_on_port 26657
        kill_pchaind_on_port 26656
        # Brief wait and verify
        sleep 1
        if lsof -tiTCP:26657 -sTCP:LISTEN 2>/dev/null | xargs -I{} ps -o comm= -p {} 2>/dev/null | grep -q "pchaind"; then
            print_warning "‚ö†Ô∏è pchaind still detected on 26657; forcing termination"
            kill_pchaind_on_port 26657
        fi
        if lsof -tiTCP:26656 -sTCP:LISTEN 2>/dev/null | xargs -I{} ps -o comm= -p {} 2>/dev/null | grep -q "pchaind"; then
            print_warning "‚ö†Ô∏è pchaind still detected on 26656; forcing termination"
            kill_pchaind_on_port 26656
        fi
        print_success "‚úÖ Node stopped"
    else
        print_warning "‚ö†Ô∏è Node is not running"
    fi
}

# Show node status
show_status() {
    echo  # Add blank line for spacing
    print_header "üìä Push Chain Node Status"
    echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    
    echo -e "${BOLD}${BLUE}Runtime Mode: ${GREEN}Native Execution${NC}"
    echo -e "  ${BOLD}Binary:${NC} $NATIVE_BINARY"
    # Get version safely with better error handling
    if [ -f "$NATIVE_BINARY" ]; then
        VERSION=$("$NATIVE_BINARY" version 2>&1 | grep -v "WARNING" | head -n1 || echo "v1.0.1-native")
        # Fallback if version command doesn't work
        if [ -z "$VERSION" ] || [ "$VERSION" = "" ]; then
            VERSION="v1.0.1-native"
        fi
    else
        VERSION="Binary not found"
    fi
    echo -e "  ${BOLD}Version:${NC} $VERSION"
    echo
    
    if [ -f "$HOME_DIR/config/config.toml" ]; then
        print_success "‚úÖ Node initialized"
        
        if is_node_running; then
            print_success "‚úÖ Node is running (PID: $(cat "$PCHAIND_PID_FILE"))"
            
            # Get detailed status
            if command -v curl >/dev/null 2>&1 && command -v jq >/dev/null 2>&1; then
                NODE_STATUS=$(http_get_quick http://localhost:26657/status 2)
                
                if [ -n "$NODE_STATUS" ]; then
                    echo
                    print_header "Node Information:"
                    echo -e "${GREEN}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
                    
                    NODE_ID=$(echo "$NODE_STATUS" | jq -r '.result.node_info.id // "unknown"' 2>/dev/null)
                    NETWORK=$(echo "$NODE_STATUS" | jq -r '.result.node_info.network // "unknown"' 2>/dev/null)  
                    MONIKER=$(echo "$NODE_STATUS" | jq -r '.result.node_info.moniker // "unknown"' 2>/dev/null)
                    
                    echo -e "  ${BOLD}Node ID:${NC} ${MAGENTA}$NODE_ID${NC}"
                    echo -e "  ${BOLD}Network:${NC} ${GREEN}$NETWORK${NC}"
                    echo -e "  ${BOLD}Moniker:${NC} ${BOLD}${WHITE}$MONIKER${NC}"
                    
                    echo
                    print_header "Sync Status:"
                    echo -e "${GREEN}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
                    
                    LOCAL_HEIGHT=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.latest_block_height // "0"' 2>/dev/null)
                    LATEST_TIME=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.latest_block_time // "unknown"' 2>/dev/null)
                    CATCHING_UP=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.catching_up // "true"' 2>/dev/null)
                    
                    # Fetch remote network height to determine actual sync status
                    REMOTE_HEIGHT=0
                    REMOTE_STATUS=$(http_get_quick "$GENESIS_RPC/status" 3)
                    if [ -n "$REMOTE_STATUS" ]; then
                        REMOTE_HEIGHT=$(echo "$REMOTE_STATUS" | jq -r '.result.sync_info.latest_block_height // "0"' 2>/dev/null || echo "0")
                    fi
                    
                    # Normalize to integers
                    [[ "$LOCAL_HEIGHT" =~ ^[0-9]+$ ]] || LOCAL_HEIGHT=0
                    [[ "$REMOTE_HEIGHT" =~ ^[0-9]+$ ]] || REMOTE_HEIGHT=0
                    
                    # Display block height with network comparison if available
                    if [ "$REMOTE_HEIGHT" -gt 0 ]; then
                        echo -e "  ${BOLD}Block Height:${NC} ${MAGENTA}$LOCAL_HEIGHT${NC} / ${MAGENTA}$REMOTE_HEIGHT${NC} (network)"
                    else
                        echo -e "  ${BOLD}Block Height:${NC} ${MAGENTA}$LOCAL_HEIGHT${NC}"
                    fi
                    echo -e "  ${BOLD}Block Time:${NC} $LATEST_TIME"
                    
                    # Determine actual sync status based on height comparison
                    if [ "$REMOTE_HEIGHT" -gt 0 ]; then
                        HEIGHT_DIFF=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
                        
                        if [ "$HEIGHT_DIFF" -le 5 ]; then
                            # Within 5 blocks of network height - considered synced
                            echo -e "  ${BOLD}Status:${NC} ${GREEN}‚úÖ Fully Synced${NC}"
                        elif [ "$HEIGHT_DIFF" -gt 5 ] && [ "$HEIGHT_DIFF" -le 100 ]; then
                            # Slightly behind but catching up
                            PROGRESS_PERCENT=$(echo "scale=2; 100 * $LOCAL_HEIGHT / $REMOTE_HEIGHT" | bc 2>/dev/null || echo "99")
                            echo -e "  ${BOLD}Status:${NC} ${YELLOW}üîÑ Syncing new blocks${NC} (${GREEN}${PROGRESS_PERCENT}%${NC})"
                        else
                            # Significantly behind - show progress
                            PROGRESS_PERCENT=$(echo "scale=2; 100 * $LOCAL_HEIGHT / $REMOTE_HEIGHT" | bc 2>/dev/null || echo "0")
                            REMAINING_BLOCKS=$HEIGHT_DIFF
                            echo -e "  ${BOLD}Status:${NC} ${YELLOW}‚è≥ Syncing...${NC} (${GREEN}${PROGRESS_PERCENT}%${NC} - ${REMAINING_BLOCKS} blocks behind)"
                        fi
                    else
                        # Fallback to original logic if can't fetch remote height
                        if [ "$CATCHING_UP" = "false" ]; then
                            echo -e "  ${BOLD}Status:${NC} ${GREEN}‚úÖ Fully Synced${NC}"
                        else
                            echo -e "  ${BOLD}Status:${NC} ${YELLOW}‚è≥ Syncing...${NC}"
                        fi
                    fi
                else
                    print_warning "‚ö†Ô∏è Node is starting up..."
                fi
            else
                print_warning "‚ö†Ô∏è curl or jq not available - install for detailed status"
            fi
        else
            print_error "‚ùå Node is not running"
            echo "Use: push-validator-manager start"
        fi
    else
        print_error "‚ùå Node not initialized"
        echo "Use: push-validator-manager start"
    fi
}

# Show logs
show_logs() {
    print_status "üìú Showing Push Chain logs..."
    
    if [ -f "$HOME_DIR/logs/pchaind.log" ]; then
        tail -f "$HOME_DIR/logs/pchaind.log"
    else
        print_warning "‚ö†Ô∏è No log file found"
        if is_node_running; then
            print_status "Node is running but logs not found at expected location"
        else
            print_status "Start the node first: push-validator-manager start"
        fi
    fi
}

# Monitor sync progress
monitor_sync() {
    MONITOR_STOPPED=0
    # Options: default is compact single-line; use -d/--dashboard for full-screen
    local COMPACT_MODE=1
    for arg in "$@"; do
        case "$arg" in
            -d|--dashboard)
                COMPACT_MODE=0
                ;;
            -c|--compact)
                COMPACT_MODE=1
                ;;
        esac
    done

    if ! is_node_running; then
        echo  # Add blank line for spacing
        print_error "‚ùå Node is not running"
        echo "Start the node first: push-validator-manager start"
        exit 1
    fi
    
    # Check if curl and jq are available
    if ! command -v curl >/dev/null 2>&1 || ! command -v jq >/dev/null 2>&1; then
        echo  # Add blank line for spacing
        print_error "‚ùå curl or jq not available"
        print_status "Install with: sudo apt-get install curl jq (Linux) or brew install curl jq (macOS)"
        exit 1
    fi
    
    local previous_height=0
    local start_time=$(date +%s)
    local last_time=$start_time

    # Prepare terminal for in-place updates when stdout is a TTY
    local is_tty=0
    if [ -t 1 ]; then
        is_tty=1
        tput civis 2>/dev/null || true
        # On Ctrl+C, restore cursor and exit successfully so callers (like install.sh)
        # don't treat this as a failure. Node continues running.
        trap 'MONITOR_STOPPED=1; tput cnorm 2>/dev/null || true; echo; echo "üìä Sync monitoring stopped. Node continues running in background."; exit 0' INT
        trap 'tput cnorm 2>/dev/null || true' TERM EXIT
        # Don't clear screen to avoid flicker
        # printf '\033[2J\033[H'
    fi
    
    while true; do
        # Move cursor to top-left and clear to end (TTY only)
        [ "${MONITOR_STOPPED:-0}" -eq 1 ] && break
        if [ "$is_tty" -eq 1 ] && [ "$COMPACT_MODE" -eq 0 ]; then
            tput cup 0 0 2>/dev/null || printf '\033[H'
            tput ed 2>/dev/null || printf '\033[J'
        fi
        
        # Get node status
                NODE_STATUS=$(http_get_quick http://localhost:26657/status 2)
        
        if [ -n "$NODE_STATUS" ]; then
            # Extract sync information
            LOCAL_HEIGHT=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.latest_block_height // "0"' 2>/dev/null || echo "0")
            CATCHING_UP=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.catching_up // "true"' 2>/dev/null || echo "true")
            LATEST_TIME=$(echo "$NODE_STATUS" | jq -r '.result.sync_info.latest_block_time // "unknown"' 2>/dev/null || echo "unknown")
            
            # Fetch remote (network) latest height to compute progress
                    REMOTE_STATUS=$(http_get_quick "$GENESIS_RPC/status" 3)
            REMOTE_HEIGHT=$(echo "$REMOTE_STATUS" | jq -r '.result.sync_info.latest_block_height // "0"' 2>/dev/null || echo "0")
            # Normalize to integers if possible
            [[ "$REMOTE_HEIGHT" =~ ^[0-9]+$ ]] || REMOTE_HEIGHT=0

            # Get network information
            MONIKER=$(echo "$NODE_STATUS" | jq -r '.result.node_info.moniker // "unknown"' 2>/dev/null || echo "unknown")
            NETWORK=$(echo "$NODE_STATUS" | jq -r '.result.node_info.network // "unknown"' 2>/dev/null || echo "unknown")
            
            # Calculate sync rate
            local current_time=$(date +%s)
            local elapsed=$((current_time - start_time))
            local interval=$((current_time - last_time))
            [ $interval -le 0 ] && interval=1
            local height_diff=$((LOCAL_HEIGHT - previous_height))
            local blocks_per_sec=$(echo "scale=2; $height_diff / $interval" | bc 2>/dev/null || echo "0")
            
            # Compute progress percentage and render a progress bar
            PROGRESS_PERCENT="0.00"
            if [ "$REMOTE_HEIGHT" -gt 0 ]; then
                if [ "$LOCAL_HEIGHT" -ge "$REMOTE_HEIGHT" ]; then
                    PROGRESS_PERCENT="100.00"
                else
                    PROGRESS_PERCENT=$(echo "scale=2; 100 * $LOCAL_HEIGHT / $REMOTE_HEIGHT" | bc 2>/dev/null || echo "0.00")
                fi
            fi
            BAR_WIDTH=$(compute_bar_width)
            FILLED=$(echo "$PROGRESS_PERCENT * $BAR_WIDTH / 100" | bc 2>/dev/null | cut -d'.' -f1)
            [ -z "$FILLED" ] && FILLED=0
            # Ensure at least 1 cell shows when progress > 0
            if [ "$FILLED" -eq 0 ] && [ "$PROGRESS_PERCENT" != "0.00" ]; then
                FILLED=1
            fi
            [ "$FILLED" -gt "$BAR_WIDTH" ] && FILLED=$BAR_WIDTH
            EMPTY=$((BAR_WIDTH - FILLED))
            BAR_FILLED=$(printf "%0.s‚ñà" $(seq 1 ${FILLED}))
            BAR_EMPTY=$(printf "%0.s‚ñë" $(seq 1 ${EMPTY}))
            PROGRESS_BAR="${GREEN}${BAR_FILLED}${NC}${DIM}${BAR_EMPTY}${NC}"
            
            if [ "$COMPACT_MODE" -eq 1 ]; then
                # Single-line compact output with colors
                local status_text="${YELLOW}‚è≥ SYNCING${NC}"
                # Determine actual sync status based on height comparison
                if [ "$REMOTE_HEIGHT" -gt 0 ]; then
                    HEIGHT_DIFF=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
                    if [ "$HEIGHT_DIFF" -le 5 ]; then
                        status_text="${GREEN}‚úÖ SYNCED${NC}"
                    elif [ "$HEIGHT_DIFF" -gt 5 ] && [ "$HEIGHT_DIFF" -le 100 ]; then
                        status_text="${YELLOW}üîÑ CATCHING UP${NC}"
                    else
                        status_text="${YELLOW}‚è≥ SYNCING${NC}"
                    fi
                elif [ "$CATCHING_UP" = "false" ]; then
                    status_text="${GREEN}‚úÖ SYNCED${NC}"
                fi
                local eta_text=""
                HEIGHT_DIFF=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
                if [ "$HEIGHT_DIFF" -gt 5 ] && [ "$REMOTE_HEIGHT" -gt "$LOCAL_HEIGHT" ]; then
                    REMAINING_BLOCKS=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
                    RATE_POS=$(echo "$blocks_per_sec > 0" | bc 2>/dev/null || echo 0)
                    if [ "$RATE_POS" -eq 1 ]; then
                        ETA_SECONDS=$(echo "$REMAINING_BLOCKS / $blocks_per_sec" | bc 2>/dev/null || echo 0)
                        if [ "$ETA_SECONDS" -gt 0 ] 2>/dev/null; then
                            ETA_H=$((ETA_SECONDS / 3600))
                            ETA_M=$(((ETA_SECONDS % 3600) / 60))
                            ETA_S=$((ETA_SECONDS % 60))
                            if [ "$ETA_H" -gt 0 ]; then
                                eta_text=" ${WHITE}~${NC}${GREEN}${ETA_H}h ${ETA_M}m${NC}"
                            elif [ "$ETA_M" -gt 0 ]; then
                                eta_text=" ${WHITE}~${NC}${GREEN}${ETA_M}m ${ETA_S}s${NC}"
                            else
                                eta_text=" ${WHITE}~${NC}${GREEN}${ETA_S}s${NC}"
                            fi
                        fi
                    fi
                fi
                # Build colored single-line summary with progress bar and print in place
                local line="${status_text} [${PROGRESS_BAR}] ${GREEN}${PROGRESS_PERCENT}%${NC} | ${BOLD}${WHITE}Height${NC} ${MAGENTA}${LOCAL_HEIGHT}${NC}/${MAGENTA}${REMOTE_HEIGHT}${NC} | ${BOLD}${WHITE}Rate${NC} ${CYAN}${blocks_per_sec}${NC} blk/s${eta_text}"
                [ "${MONITOR_STOPPED:-0}" -eq 1 ] && break
                printf "\r%b\033[K" "$line"
            else
                # Full-screen rich output
                echo -e "${BOLD}${GREEN}Push Chain Sync Monitor${NC}"
                echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
                echo
                print_header "Node Information:"
                echo -e "  ${BOLD}Moniker:${NC} ${WHITE}$MONIKER${NC}"
                echo -e "  ${BOLD}Network:${NC} ${GREEN}$NETWORK${NC}"
                echo
                
                print_header "Sync Status:"
                echo -e "  ${BOLD}Block Height:${NC} ${MAGENTA}$LOCAL_HEIGHT${NC}"
                echo -e "  ${BOLD}Last Block:${NC} $LATEST_TIME"
                
                # Determine actual sync status based on height comparison
                local is_synced=0
                if [ "$REMOTE_HEIGHT" -gt 0 ]; then
                    HEIGHT_DIFF=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
                    if [ "$HEIGHT_DIFF" -le 5 ]; then
                        is_synced=1
                        echo -e "  ${BOLD}Status:${NC} ${GREEN}‚úÖ FULLY SYNCED${NC}"
                        echo -e "  ${BOLD}Sync Rate:${NC} ${GREEN}Maintaining sync${NC}"
                    elif [ "$HEIGHT_DIFF" -gt 5 ] && [ "$HEIGHT_DIFF" -le 100 ]; then
                        echo -e "  ${BOLD}Status:${NC} ${YELLOW}üîÑ CATCHING UP${NC} (${HEIGHT_DIFF} blocks behind)"
                    else
                        echo -e "  ${BOLD}Status:${NC} ${YELLOW}‚è≥ SYNCING...${NC}"
                    fi
                elif [ "$CATCHING_UP" = "false" ]; then
                    is_synced=1
                    echo -e "  ${BOLD}Status:${NC} ${GREEN}‚úÖ FULLY SYNCED${NC}"
                    echo -e "  ${BOLD}Sync Rate:${NC} ${GREEN}Maintaining sync${NC}"
                else
                    echo -e "  ${BOLD}Status:${NC} ${YELLOW}‚è≥ SYNCING...${NC}"
                fi
                
                if [ "$is_synced" -eq 0 ]; then
                    if [ "$blocks_per_sec" != "0" ]; then
                        echo -e "  ${BOLD}Sync Rate:${NC} ${CYAN}${blocks_per_sec} blocks/sec${NC}"
                        # Estimate ETA based on remaining blocks and current rate
                        if [ "$REMOTE_HEIGHT" -gt "$LOCAL_HEIGHT" ]; then
                            REMAINING_BLOCKS=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
                            RATE_POS=$(echo "$blocks_per_sec > 0" | bc 2>/dev/null || echo 0)
                            if [ "$RATE_POS" -eq 1 ]; then
                                ETA_SECONDS=$(echo "$REMAINING_BLOCKS / $blocks_per_sec" | bc 2>/dev/null || echo 0)
                                if [ "$ETA_SECONDS" -gt 0 ] 2>/dev/null; then
                                    ETA_H=$((ETA_SECONDS / 3600))
                                    ETA_M=$(((ETA_SECONDS % 3600) / 60))
                                    ETA_S=$((ETA_SECONDS % 60))
                                    if [ "$ETA_H" -gt 0 ]; then
                                        echo -e "  ${BOLD}ETA:${NC} ~${GREEN}${ETA_H}h ${ETA_M}m${NC}"
                                    elif [ "$ETA_M" -gt 0 ]; then
                                        echo -e "  ${BOLD}ETA:${NC} ~${GREEN}${ETA_M}m ${ETA_S}s${NC}"
                                    else
                                        echo -e "  ${BOLD}ETA:${NC} ~${GREEN}${ETA_S}s${NC}"
                                    fi
                                fi
                            fi
                        fi
                    fi
                fi
                
                echo
                print_header "Runtime Stats:"
                echo -e "  ${BOLD}Monitoring Time:${NC} ${elapsed}s"
                if [ "$REMOTE_HEIGHT" -gt 0 ]; then
                    echo -e "  ${BOLD}Progress:${NC} [${PROGRESS_BAR}] ${GREEN}${PROGRESS_PERCENT}%${NC} (${MAGENTA}${LOCAL_HEIGHT}${NC}/${MAGENTA}${REMOTE_HEIGHT}${NC})"
                else
                    echo -e "  ${BOLD}Progress:${NC} [${PROGRESS_BAR}] ${YELLOW}unknown target height${NC} (${MAGENTA}${LOCAL_HEIGHT}${NC}/?)"
                fi
                
                if [ "$is_synced" -eq 1 ]; then
                    echo
                    echo -e "${BOLD}${GREEN}üéâ Node is fully synced and ready!${NC}"
                    echo -e "You can now register as validator: ${BOLD}push-validator-manager register-validator${NC}"
                fi
                
                echo
                print_status "Press Ctrl+C to exit monitor"
            fi

            previous_height=$LOCAL_HEIGHT
            last_time=$current_time
            
        else
            # Silently wait for node to respond
            :
        fi
        
        if [ "$COMPACT_MODE" -eq 1 ]; then
            sleep 1
        else
            sleep 3
        fi
    done
}

# Register validator
register_validator() {
    echo  # Add blank line for spacing
    print_status "üöÄ Starting validator registration..."
    
    if [ -f "$SCRIPT_DIR/scripts/register-validator.sh" ]; then
        bash "$SCRIPT_DIR/scripts/register-validator.sh"
    else
        print_error "‚ùå Validator registration script not found!"
        exit 1
    fi
}

# Configure genesis RPC endpoint
configure_genesis() {
    if [ -n "${2-}" ]; then
        NEW_GENESIS_DOMAIN="$2"
        print_status "üîß Setting genesis RPC domain to: $NEW_GENESIS_DOMAIN"
        
        # Create/update .env file for persistence
        ENV_FILE="$SCRIPT_DIR/.env"
        if [ -f "$ENV_FILE" ]; then
            # Remove existing GENESIS_DOMAIN line
            grep -v "^GENESIS_DOMAIN=" "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE" || touch "$ENV_FILE"
        fi
        echo "GENESIS_DOMAIN=$NEW_GENESIS_DOMAIN" >> "$ENV_FILE"
        
        print_success "‚úÖ Genesis RPC configured: https://$NEW_GENESIS_DOMAIN"
        print_status "üí° This setting will persist across restarts"

        # If node already initialized, update persistent_peers accordingly
        if [ -f "$HOME_DIR/config/config.toml" ]; then
            # Try to get multiple peers from the new genesis domain
            NEW_PEERS=""
            PEERS_JSON=$(http_get_quick "https://$NEW_GENESIS_DOMAIN/net_info" 3)
            [ -n "$PEERS_JSON" ] || PEERS_JSON='{}'
            
            if [ -n "$PEERS_JSON" ] && [ "$PEERS_JSON" != '{}' ]; then
                PEER_LIST=$(echo "$PEERS_JSON" | jq -r '.result.peers[]? | "\(.node_info.id)@\(.remote_ip):26656"' 2>/dev/null | head -3 || true)
                if [ -n "$PEER_LIST" ]; then
                    NEW_PEERS=$(echo "$PEER_LIST" | tr '\n' ',' | sed 's/,$//')
                fi
            fi
            
            # Fallback to single peer
            if [ -z "$NEW_PEERS" ]; then
                NEW_NODE_ID=$(http_get_quick "https://$NEW_GENESIS_DOMAIN/status" 3 | jq -r '.result.node_info.id // empty' || true)
                NEW_IP=$(resolve_host_ip "$NEW_GENESIS_DOMAIN")
                if [ -n "$NEW_NODE_ID" ] && [ -n "$NEW_IP" ]; then
                    NEW_PEERS="$NEW_NODE_ID@$NEW_IP:26656"
                fi
            fi
            
            if [ -n "$NEW_PEERS" ]; then
                sed -i.bak -e "s/^persistent_peers = .*/persistent_peers = \"$NEW_PEERS\"/" -e "s/^addr_book_strict = .*/addr_book_strict = false/" "$HOME_DIR/config/config.toml"
                print_success "üîó Updated persistent_peers to $NEW_PEERS"
                print_status "üîÑ Restart the node to apply the new peers: push-validator-manager restart"
            else
                print_warning "‚ö†Ô∏è Could not resolve new peer info; leaving config unchanged."
            fi
        else
            print_status "üîÑ Start will use the new endpoint on first initialization"
        fi
    else
        print_header "üì° Current Genesis RPC Configuration"
        echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
        echo -e "  ${BOLD}Domain:${NC} ${MAGENTA}$GENESIS_DOMAIN${NC}"
        echo -e "  ${BOLD}Full URL:${NC} ${MAGENTA}$GENESIS_RPC${NC}"
        echo
        print_status "üí° To change: push-validator-manager set-genesis <domain>"
        print_status "   Example: push-validator-manager set-genesis rpc.custom-node.org"
        echo
        print_status "üîß Default: rpc-testnet-donut-node1.push.org"
    fi
}

# Check wallet balance
check_balance() {
    WALLET_NAME="${2:-validator-key}"
    print_status "üí∞ Checking wallet balance..."
    
    # Check if wallet exists
    if ! "$NATIVE_BINARY" keys show "$WALLET_NAME" --keyring-backend "$KEYRING_BACKEND" --home "$HOME_DIR" >/dev/null 2>&1; then
        print_error "‚ùå Wallet '$WALLET_NAME' not found!"
        echo "Create a wallet first using: push-validator-manager register-validator"
        exit 1
    fi
    
    # Get address
    ADDRESS=$("$NATIVE_BINARY" keys show "$WALLET_NAME" -a --keyring-backend "$KEYRING_BACKEND" --home "$HOME_DIR" 2>/dev/null)
    
    echo "Wallet: $WALLET_NAME"
    echo "Address: $ADDRESS"
    
    # Get balance from remote RPC for accuracy
    BALANCE=$("$NATIVE_BINARY" query bank balances "$ADDRESS" --node "tcp://$GENESIS_DOMAIN:26657" -o json 2>/dev/null | \
        jq -r '.balances[] | select(.denom=="upc") | .amount // "0"' || echo "0")
    
    if [ "$BALANCE" != "0" ] && [ -n "$BALANCE" ]; then
        # Convert to PUSH (divide by 10^18) using awk
        PUSH_AMOUNT=$(awk -v bal="$BALANCE" 'BEGIN {printf "%.6f", bal/1000000000000000000}')
        print_success "Balance: $PUSH_AMOUNT PUSH"
    else
        print_warning "Balance: 0 PUSH"
        
        # Convert to EVM address for faucet
        EVM_ADDRESS=$("$NATIVE_BINARY" debug addr "$ADDRESS" --home "$HOME_DIR" 2>/dev/null | grep "hex" | awk '{print "0x"$3}')
        
        if [ -n "$EVM_ADDRESS" ]; then
            echo
            echo "To get test tokens:"
            echo -e "${GREEN}1. Visit: https://faucet.push.org${NC}"
            echo -e "${GREEN}2. Use this address: ${BOLD}$EVM_ADDRESS${NC}"
        else
            echo "Get test tokens at: https://faucet.push.org"
        fi
    fi
}

# List validators
list_validators() {
    print_header "üë• Active Push Chain Validators"
    echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    
    if is_node_running; then
        # Always use remote RPC for validator queries since we need network-wide data
        NODE_ENDPOINT="tcp://$GENESIS_DOMAIN:26657"
        
        VALIDATORS=$("$NATIVE_BINARY" query staking validators --output json --node "$NODE_ENDPOINT" 2>/dev/null | jq -r '.validators[]' 2>/dev/null || echo "")
        
        if [ -n "$VALIDATORS" ]; then
            echo
            printf "${BOLD}${YELLOW}%-26s %-12s %12s %11s${NC}\n" "VALIDATOR" "STATUS" "STAKE (PC)" "COMMISSION"
            echo -e "${BLUE}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
            
            echo "$VALIDATORS" | jq -r '
                (.description.moniker // "unknown") + "|" + 
                (if .status == "BOND_STATUS_BONDED" then "BONDED" 
                 elif .status == "BOND_STATUS_UNBONDING" then "UNBONDING"
                 elif .status == "BOND_STATUS_UNBONDED" then "UNBONDED"
                 else .status end) + "|" +
                ((.tokens | tonumber / 1000000000000000000) | tostring | split(".")[0]) + "|" +
                ((.commission.commission_rates.rate | tonumber * 100) | tostring | split(".")[0]) + "%"
            ' 2>/dev/null | while IFS='|' read -r moniker status tokens commission; do
                # Pre-pad fields WITHOUT color so width counts are correct
                moniker_padded=$(printf "%-26s" "$moniker")
                status_padded=$(printf "%-12s" "$status")
                tokens_padded=$(printf "%12s" "$tokens")
                commission_padded=$(printf "%11s" "$commission")

                # Apply colors after padding
                case "$status" in
                    "BONDED")     status_colored="${GREEN}${status_padded}${NC}" ;;
                    "UNBONDING")  status_colored="${YELLOW}${status_padded}${NC}" ;;
                    "UNBONDED")   status_colored="${RED}${status_padded}${NC}" ;;
                    *)             status_colored="${CYAN}${status_padded}${NC}" ;;
                esac

                echo -e "${BOLD}${moniker_padded}${NC} ${status_colored} ${MAGENTA}${tokens_padded}${NC} ${MAGENTA}${commission_padded}${NC}"
            done
            
            echo
            print_status "Total Validators: $(echo "$VALIDATORS" | jq -s length)"
        else
            print_warning "No validators found or node not synced"
        fi
    else
        print_error "‚ùå Node must be running to query validators"
        echo "Start the node first: push-validator-manager start"
    fi
}

# Show help
show_help() {
    echo
    echo -e "${BOLD}${GREEN}Push Validator Manager${NC}"
    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo
    echo -e "${BOLD}Usage:${NC} push-validator-manager [command] [options]"
    echo
    echo -e "${BOLD}${CYAN}CORE COMMANDS${NC}"
    printf "  ${BOLD}%-18s${NC}%s\n" "start" "Start the Push node"
    printf "  ${BOLD}%-18s${NC}%s\n" "stop" "Stop the Push node"
    printf "  ${BOLD}%-18s${NC}%s\n" "status" "Check node status"
    printf "  ${BOLD}%-18s${NC}%s\n" "sync [-d]" "Monitor sync. Use -d for dashboard"
    printf "  ${BOLD}%-18s${NC}%s\n" "logs" "View node logs"
    echo
    echo -e "${BOLD}${CYAN}VALIDATOR${NC}"
    echo -e "  ${BOLD}register-validator${NC}  Register as validator"
    echo -e "  ${BOLD}validators${NC}          List all validators"
    echo -e "  ${BOLD}balance${NC} [wallet]    Check wallet balance"
    echo
    echo -e "${BOLD}${CYAN}CONFIGURATION${NC}"
    echo -e "  ${BOLD}set-genesis${NC} <url>   Set genesis RPC endpoint"
    echo -e "  ${BOLD}reset${NC}               Reset blockchain data"
    echo -e "  ${BOLD}setup-deps${NC}          Install dependencies"
    echo
    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${BOLD}${YELLOW}QUICK START${NC}"
    echo -e "  1. push-validator-manager ${BOLD}start${NC}"
    echo -e "  2. push-validator-manager ${BOLD}status${NC}"
    echo -e "  3. push-validator-manager ${BOLD}register-validator${NC}"
    echo
    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${BOLD}NETWORK${NC}"
    echo -e "  Chain ID:    ${YELLOW}push_42101-1${NC}"
    echo -e "  Network:     ${YELLOW}Testnet${NC}"
    echo -e "  RPC:         ${YELLOW}http://localhost:26657${NC}"
    echo -e "  Genesis RPC: ${YELLOW}https://$GENESIS_DOMAIN${NC}"
    echo -e "  Faucet:      ${YELLOW}https://faucet.push.org${NC}"
    echo
    echo -e "${BOLD}DATA LOCATIONS${NC}"
    echo -e "  Node data:   ${YELLOW}~/.pchain${NC}"
    echo -e "  Logs:        ${YELLOW}~/.pchain/logs/pchaind.log${NC}"
    echo
}

# Command handling
###############################################################################
# WebSocket-driven sync monitoring (with graceful fallback)
###############################################################################

# Optional user hook: override this function in the environment to run custom
# actions once the node is fully synced. Default prints helpful guidance.
on_fully_synced() {
    print_success "üéâ Node is fully synced and ready!"
    echo -e "You can now register as validator: ${BOLD}push-validator-manager register-validator${NC}"
    # If a user-provided hook script exists, run it
    if [ -x "$SCRIPT_DIR/scripts/on-synced.sh" ]; then
        "$SCRIPT_DIR/scripts/on-synced.sh" || true
    fi
}

# Try WebSocket monitor first; if unavailable, fall back to the existing polling
monitor_sync_auto() {
    # Run monitors in subshells to isolate traps and avoid double-handling Ctrl+C
    ( monitor_sync_ws "$@" ) && return 0
    ( monitor_sync "$@" )
}

# WebSocket monitor using websocat or wscat
monitor_sync_ws() {
    MONITOR_STOPPED=0
    
    # Options: default is compact single-line; use -d/--dashboard for full-screen
    local COMPACT_MODE=1
    for arg in "$@"; do
        case "$arg" in
            -d|--dashboard) COMPACT_MODE=0 ;;
            -c|--compact) COMPACT_MODE=1 ;;
        esac
    done

    # Require running node
    if ! is_node_running; then
        echo
        print_error "‚ùå Node is not running"
        echo "Start the node first: push-validator-manager start"
        return 1
    fi

    # Detect WebSocket client
    local WS_CLIENT=""
    if command -v websocat >/dev/null 2>&1; then
        WS_CLIENT="websocat"
    elif command -v wscat >/dev/null 2>&1; then
        WS_CLIENT="wscat"
    else
        print_warning "‚ö†Ô∏è No WebSocket client (websocat/wscat) found; falling back to polling."
        return 1
    fi

    local start_time=$(date +%s)
    local last_time=$start_time
    local previous_height=0
    local last_event_time=$start_time
    local avg_interval_sum=0
    local avg_interval_count=0
    local REMOTE_HEIGHT=0
    local last_remote_poll=$start_time
    local FULLY_SYNCED_ONCE=0
    local reconnects=0
    local LOCAL_HEIGHT=0

    # Prepare terminal when TTY
    local is_tty=0
    if [ -t 1 ]; then
        is_tty=1
        tput civis 2>/dev/null || true
        trap 'MONITOR_STOPPED=1; tput cnorm 2>/dev/null || true; echo; echo "üìä Sync monitoring stopped. Node continues running in background."; exit 0' INT
    fi

    # Helper: render current status in compact or dashboard mode
    render_ws_view() {
        [ "${MONITOR_STOPPED:-0}" -eq 1 ] && return 0
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))

        # Refresh remote height every 5 seconds for accurate percentage/ETA
        if [ $((current_time - last_remote_poll)) -ge 5 ]; then
            local REMOTE_STATUS=$(http_get_quick "$GENESIS_RPC/status" 3)
            local RH=$(echo "$REMOTE_STATUS" | jq -r '.result.sync_info.latest_block_height // "0"' 2>/dev/null || echo "0")
            [[ "$RH" =~ ^[0-9]+$ ]] || RH=0
            REMOTE_HEIGHT=$RH
            last_remote_poll=$current_time
        fi

        # Compute blocks/sec using previous_height/last_time deltas
        local interval=$((current_time - last_time)); [ $interval -le 0 ] && interval=1
        local height_diff=$((LOCAL_HEIGHT - previous_height))
        local blocks_per_sec=$(echo "scale=2; $height_diff / $interval" | bc 2>/dev/null || echo "0")

        # Progress bar
        local PROGRESS_PERCENT="0.00"
        if [ "$REMOTE_HEIGHT" -gt 0 ]; then
            if [ "$LOCAL_HEIGHT" -ge "$REMOTE_HEIGHT" ]; then
                PROGRESS_PERCENT="100.00"
            else
                PROGRESS_PERCENT=$(echo "scale=2; 100 * $LOCAL_HEIGHT / $REMOTE_HEIGHT" | bc 2>/dev/null || echo "0.00")
            fi
        fi
        local BAR_WIDTH=$(compute_bar_width)
        local FILLED=$(echo "$PROGRESS_PERCENT * $BAR_WIDTH / 100" | bc 2>/dev/null | cut -d'.' -f1)
        [ -z "$FILLED" ] && FILLED=0
        if [ "$FILLED" -eq 0 ] && [ "$PROGRESS_PERCENT" != "0.00" ]; then
            FILLED=1
        fi
        [ "$FILLED" -gt "$BAR_WIDTH" ] && FILLED=$BAR_WIDTH
        local EMPTY=$((BAR_WIDTH - FILLED))
        local BAR_FILLED=$(printf "%0.s‚ñà" $(seq 1 ${FILLED}))
        local BAR_EMPTY=$(printf "%0.s‚ñë" $(seq 1 ${EMPTY}))
        local PROGRESS_BAR="${GREEN}${BAR_FILLED}${NC}${DIM}${BAR_EMPTY}${NC}"

        # Connection quality: degrade with reconnects and long gaps
        local gap=$((current_time - last_event_time))
        local quality=$((100 - reconnects*15))
        [ $quality -lt 10 ] && quality=10
        if [ $gap -gt 10 ]; then quality=$((quality - 20)); [ $quality -lt 5 ] && quality=5; fi
        local quality_text="Good"; [ $quality -lt 70 ] && quality_text="OK"; [ $quality -lt 40 ] && quality_text="Poor"

        # Average block interval (seconds)
        local avg_block_time=""
        if [ $avg_interval_count -gt 0 ]; then
            avg_block_time=$(echo "scale=2; $avg_interval_sum / $avg_interval_count" | bc 2>/dev/null || echo "0")
        else
            avg_block_time="0"
        fi

        # Status text based on proximity to head
        local status_text="${YELLOW}‚è≥ SYNCING${NC}"
        if [ "$REMOTE_HEIGHT" -gt 0 ]; then
            local HEIGHT_DIFF=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
            if [ "$HEIGHT_DIFF" -le 5 ]; then
                status_text="${GREEN}‚úÖ SYNCED${NC}"
            elif [ "$HEIGHT_DIFF" -le 100 ]; then
                status_text="${YELLOW}üîÑ CATCHING UP${NC}"
            fi
        fi

        if [ "${MONITOR_STOPPED:-0}" -eq 1 ]; then return 0; fi
        if [ "$COMPACT_MODE" -eq 1 ]; then
            # Compose single-line summary with bar and ETA
            local eta_text=""
            local HEIGHT_DIFF=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
            if [ "$HEIGHT_DIFF" -gt 5 ] && [ "$REMOTE_HEIGHT" -gt "$LOCAL_HEIGHT" ]; then
                local REMAINING_BLOCKS=$HEIGHT_DIFF
                local RATE_POS=$(echo "$blocks_per_sec > 0" | bc 2>/dev/null || echo 0)
                if [ "$RATE_POS" -eq 1 ]; then
                    local ETA_SECONDS=$(echo "$REMAINING_BLOCKS / $blocks_per_sec" | bc 2>/dev/null || echo 0)
                    if [ "$ETA_SECONDS" -gt 0 ] 2>/dev/null; then
                        local ETA_H=$((ETA_SECONDS / 3600))
                        local ETA_M=$(((ETA_SECONDS % 3600) / 60))
                        local ETA_S=$((ETA_SECONDS % 60))
                        if [ "$ETA_H" -gt 0 ]; then
                            eta_text=" ${WHITE}~${NC}${GREEN}${ETA_H}h ${ETA_M}m${NC}"
                        elif [ "$ETA_M" -gt 0 ]; then
                            eta_text=" ${WHITE}~${NC}${GREEN}${ETA_M}m ${ETA_S}s${NC}"
                        else
                            eta_text=" ${WHITE}~${NC}${GREEN}${ETA_S}s${NC}"
                        fi
                    fi
                fi
            fi
            local line="${status_text} [${PROGRESS_BAR}] ${GREEN}${PROGRESS_PERCENT}%${NC} | ${BOLD}${WHITE}Height${NC} ${MAGENTA}${LOCAL_HEIGHT}${NC}/${MAGENTA}${REMOTE_HEIGHT}${NC} | ${BOLD}${WHITE}Rate${NC} ${CYAN}${blocks_per_sec}${NC} blk/s${eta_text}"
            [ "${MONITOR_STOPPED:-0}" -eq 1 ] && return 0
            printf "\r%b\033[K" "$line"
        else
            if [ "$is_tty" -eq 1 ]; then
                tput cup 0 0 2>/dev/null || printf '\033[H'
                tput ed 2>/dev/null || printf '\033[J'
            fi
            [ "${MONITOR_STOPPED:-0}" -eq 1 ] && return 0
            echo -e "${BLUE}üìä Push Chain Sync (WebSocket)${NC}"
            echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
            echo -e "  ${BOLD}Block Height:${NC} ${MAGENTA}${LOCAL_HEIGHT:-0}${NC}/${MAGENTA}${REMOTE_HEIGHT:-0}${NC}"
            echo -e "  ${BOLD}Status:${NC} $status_text"
            echo -e "  ${BOLD}Rate:${NC} ${CYAN}${blocks_per_sec} blocks/sec${NC}"
            echo -e "  ${BOLD}Avg Block Time:${NC} ${CYAN}${avg_block_time}s${NC}"
            echo -e "  ${BOLD}Connection:${NC} ${CYAN}${quality_text}${NC} (${quality}%)"
            echo -e "  ${BOLD}Progress:${NC} [${PROGRESS_BAR}] ${GREEN}${PROGRESS_PERCENT}%${NC}"
            echo -e "  ${BOLD}Monitoring Time:${NC} $((elapsed))s"
            echo
            print_status "Press Ctrl+C to exit monitor"
        fi

            [ "${MONITOR_STOPPED:-0}" -eq 1 ] && return 0
            previous_height=$LOCAL_HEIGHT
            last_time=$current_time
    }

    # Perform an immediate initial fetch to avoid blank screen while connecting
    local INIT_STATUS=$(http_get_quick http://localhost:26657/status 2)
    if [ -n "$INIT_STATUS" ]; then
        LOCAL_HEIGHT=$(echo "$INIT_STATUS" | jq -r '.result.sync_info.latest_block_height // "0"' 2>/dev/null || echo "0")
        [[ "$LOCAL_HEIGHT" =~ ^[0-9]+$ ]] || LOCAL_HEIGHT=0
        previous_height=$LOCAL_HEIGHT
    fi
    # Render once immediately so users see progress without waiting for first event
    render_ws_view || true

    # Subscribe helper: run client and stream events; returns on disconnect
    _run_subscription() {
        local query="$1"
        local payload='{\"jsonrpc\":\"2.0\",\"method\":\"subscribe\",\"params\":{\"query\":'"\"$query\""'},\"id\":1}'
        if [ "$WS_CLIENT" = "websocat" ]; then
            # Send subscribe JSON and stream messages
            # shellcheck disable=SC2005
            ( echo "$payload"; ) | websocat -t ws://localhost:26657/websocket 2>/dev/null
        else
            # wscat can send once with -x and print responses
            wscat -c ws://localhost:26657/websocket -x "$payload" 2>/dev/null
        fi
    }

    # Attempt multiple query forms; keep reconnecting. If we fail repeatedly
    # without receiving any events, let caller fallback to polling.
    local queries=("cometbft.event='NewBlockHeader'" "tm.event='NewBlockHeader'" "tm.event='NewBlock'")
    local noevent_streak=0
    local TMP_RECEIVED="/tmp/pnm_ws_${$}_received"
    # Use a function to clean up to avoid variable evaluation issues
    cleanup_tmp_received() { rm -f "/tmp/pnm_ws_${$}_received" 2>/dev/null || true; }
    trap cleanup_tmp_received EXIT
    : > "$TMP_RECEIVED" 2>/dev/null || true

    while true; do
        local got_event=0
        for q in "${queries[@]}"; do
            : > "$TMP_RECEIVED" 2>/dev/null || true
            # Use process substitution with read timeout so we don't block forever
            exec 3< <(_run_subscription "$q")
            while IFS= read -r -t 2 line <&3; do
            [ "${MONITOR_STOPPED:-0}" -eq 1 ] && break
            # Extract height from either NewBlock or NewBlockHeader shapes
            local h
                h=$(echo "$line" | jq -r '(.result.data.value.block.header.height // .result.data.value.header.height // empty)') || h=""
                if [ -z "$h" ] || [ "$h" = "null" ]; then
                    continue
                fi

                # Normalize height
                if [[ "$h" =~ ^[0-9]+$ ]]; then
                    LOCAL_HEIGHT=$h
                else
                    continue
                fi

                # Mark that we received at least one event in this attempt
                echo 1 > "$TMP_RECEIVED" 2>/dev/null || true

                # Update average block interval from event arrival spacing (wall clock)
                local now=$(date +%s)
                local delta=$((now - last_event_time))
                if [ $delta -gt 0 ]; then
                    avg_interval_sum=$((avg_interval_sum + delta))
                    avg_interval_count=$((avg_interval_count + 1))
                fi
                last_event_time=$now

                # Render UI and possibly invoke hook when considered synced
                render_ws_view

                # Trigger on_fully_synced once when near head
                if [ "${MONITOR_STOPPED:-0}" -eq 0 ] && [ "$FULLY_SYNCED_ONCE" -eq 0 ] && [ "$REMOTE_HEIGHT" -gt 0 ] && [ $((REMOTE_HEIGHT - LOCAL_HEIGHT)) -le 5 ]; then
                    echo
                    on_fully_synced || true
                    FULLY_SYNCED_ONCE=1
                fi
            done
            exec 3<&-

            if [ -s "$TMP_RECEIVED" ]; then
                got_event=1
                break
            fi
            # No events in this attempt; render to keep UI fresh
            render_ws_view || true
        done

        if [ "$got_event" -eq 1 ]; then
            noevent_streak=0
        else
            noevent_streak=$((noevent_streak + 1))
        fi

        reconnects=$((reconnects + 1))

        # If we failed to get events several times in a row, fallback
        if [ "$noevent_streak" -ge 3 ]; then
            # Do not print a newline; let the fallback monitor redraw on the same line
            return 1
        fi

        # Small backoff before trying again
        sleep 2
    done
}

###############################################################################
# Command handling
###############################################################################

case "${1:-help}" in
    start|run)
        show_banner
        start_node
        ;;
        
    stop)
        stop_node
        ;;
        
    restart)
        stop_node
        sleep 2
        start_node
        ;;
        
    status)
        show_status
        ;;
        
    sync)
        monitor_sync_auto ${@:2}
        ;;
        
    logs)
        show_logs
        ;;
        
    register-validator|setup)
        show_banner
        register_validator
        ;;
        
    balance|wallet)
        check_balance "$@"
        ;;
        
    validators)
        list_validators
        ;;
        
    set-genesis)
        configure_genesis "$@"
        ;;
        
    genesis)
        configure_genesis "$@"
        ;;
        
    setup-deps)
        print_status "üîß Running dependency setup..."
        bash "$SCRIPT_DIR/scripts/setup-dependencies.sh"
        ;;
        
    reset)
        print_warning "‚ö†Ô∏è This will reset all blockchain data (wallets will be preserved)"
        read -p "Continue? (yes/no): " confirm
        if [[ "$confirm" =~ ^[Yy][Ee][Ss]$ ]]; then
            stop_node
            print_status "üßπ Removing blockchain data..."
            rm -rf "$HOME_DIR/data"
            rm -f "$HOME_DIR/config/genesis.json"
            rm -f "$HOME_DIR/config/addrbook.json"
            rm -f "$HOME_DIR/config/config.toml.bak"
            
            # Additional thorough cleanup for AppHash errors
            print_status "üîß Performing thorough cleanup..."
            rm -rf "$HOME_DIR/data" 2>/dev/null || true
            rm -rf "$HOME_DIR/wasm" 2>/dev/null || true
            rm -f "$HOME_DIR/config/config.toml" 2>/dev/null || true
            rm -rf "$HOME_DIR/logs" 2>/dev/null || true
            
            print_success "‚úÖ Blockchain data reset completely"
            print_status "Node will be completely re-initialized on next start"
            print_status "Start the node to re-sync: push-validator-manager start"
        fi
        ;;
        
    setup-nginx)
        if [ -z "${2:-}" ]; then
            print_error "‚ùå Domain required for NGINX setup"
            echo "Usage: push-validator-manager setup-nginx yourdomain.com"
            exit 1
        fi
        bash "$SCRIPT_DIR/scripts/setup-nginx.sh" "$2"
        ;;
        
    setup-logs)
        bash "$SCRIPT_DIR/scripts/setup-log-rotation.sh"
        ;;
        
    backup)
        bash "$SCRIPT_DIR/scripts/backup.sh"
        ;;
        
    help|--help|-h|"")
        show_help
        ;;
        
    *)
        print_error "‚ùå Unknown command: $1"
        echo "Use 'push-validator-manager help' for usage information"
        exit 1
        ;;
esac
